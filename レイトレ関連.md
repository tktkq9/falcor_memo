# レイトレ関連
Falcorプロジェクトのレイトレに関する部分のまとめ  

## PathTracer関連
Mogwaiとかで使われるレイトレパスのベースクラスとその仲間たち  
パスの他に、それのデバッグをサポートするクラスや、レイトレ用の共通関数や構造体などをまとめたシェーダーなどがある  
ただし、シェーダーもPathTracerもこれ単体では動かないのでそれを利用したクラスとシェーダーがいる  

クラス
- PathTracer : レイトレパスのベースクラス。これを継承してレイトレパスが作られる（継承してないやつももちろんある。GBufferRTとか）
- PixelStats : デバッグ用、描画した際の統計情報など  
- PixelDebug : デバッグ用、クリックした位置のピクセル情報取得と表示、[未分類.md](https://github.com/tktkq9/falcor_memo/blob/master/%E6%9C%AA%E5%88%86%E9%A1%9E.md)参照
シェーダー
- a
- 

### PathTracer.h, cpp
RenderPassのサブクラスなのでMogwaiとかで使われるタイプのやつ  
レイトレパスのベースクラスであり、これのサブクラスがMogwaiで使われ、これ自体は使われない  




Input : kGBufferInputChannels（GBufferのサブクラスパスで作成される）かkVBufferInputChannels（VBufferRasterizeまたはVBufferRTパスで作成される）のどちらかをuseVBufferで設定できる  
output : mOutputChannels、複数、サブクラスで指定  
output : rayCount、ピクセルごとのサンプル数  
output : pathLength、ピクセルごとのレイの距離      

#### その他細かなこと

1ピクセルで使うサンプル数はパスの各種設定によって決まり、  
ざっくり説明すると、1ピクセルあたりのサンプル数 * （散乱回数 + シャドウサンプル数）  
正確にはmaxRaysPerPixel()参照  

DOFもできるが、viewWインプットが必要  
つまり、VBufferインプットの場合はDOFはサポートされていない  

setStaticParams()でStaticParams.slang（とMaterialShading.slangの_USE_LEGACY_SHADING_CODE）の値を設定する  


#### StaticParams.slang
PathTracerのためのシェーダー側のconst値をまとめたもの  
PathTracer.cppのsetStaticParams()で（半分以上はPathTracerParamsの値を用いて）設定され、その後この設定をもとにシェーダーがコンパイルされるという流れ  
一応コードに書かれている各変数の説明もコピペしておく  

    /** Translation of defines set by the host to compile-time constants used to
        configure the path tracer without overhead from dynamic control flow.
        This will eventually be replaced by specialization constants in Slang.

        The host sets the following defines (booleans are 1=true, 0=false):

        SAMPLES_PER_PIXEL               Number of paths to trace per pixel.
        LIGHT_SAMPLES_PER_VERTEX        Number of light sampler per path vertex.
        MAX_BOUNCES                     Maximum number of indirect bounces (0 means no indirect).
        MAX_NON_SPECULAR_BOUNCES        Maximum number of non-specular indirect bounces (0 means no indirect).
        USE_VBUFFER                     Use a V-buffer as input.
        FORCE_ALPHA_ONE                 Force the alpha channel to 1.0.
        USE_ANALYTIC_LIGHTS             Enables Falcor's analytic lights (point, directional).
        USE_EMISSIVE_LIGHTS             Enables use of emissive geometry as light sources.
        USE_EMISSIVE_SAMPLER            True if the emissive light sampler should be used.
        USE_ENV_LIGHT                   True if env map is available and should be used as light source.
        USE_ENV_BACKGROUND              True if env map is available and should be used as background.
        USE_BRDF_SAMPLING               Enables BRDF importance sampling.
        USE_MIS                         Enables multiple importance sampling.
        USE_RUSSIAN_ROULETTE            Enables Russian roulette for path termination.
        MIS_HEURISTIC                   MIS heuristic enum value.
        USE_NESTED_DIELECTRICS          Enables nested dielectrics handling.
        USE_LIGHTS_IN_VOLUMES           Enables lights in volumes.
        DISABLE_CAUSTICS                Disables caustics.
    */

### PathTracerParams.slang
どのようなレイトレをするかの設定パラメーター  
サンプル数、bounce回数、スペキュラー反射の有無と設定、NEE（next-event estimation、ライトに対する重要度サンプリングのこと）とMISを行うかどうかなど、レイトレアルゴリズムの設定が主な内容となっている  
詳しくはPathTracerParams.slangの変数それぞれに説明が書いてあるのでここにコピペしておく  

    struct PathTracerParams
    {
        // Make sure struct layout follows the HLSL packing rules as it is uploaded as a memory blob.
        // Do not use bool's as they are 1 byte in Visual Studio, 4 bytes in HLSL.
        // https://msdn.microsoft.com/en-us/library/windows/desktop/bb509632(v=vs.85).aspx
        // Note that the default initializers are ignored by Slang but used on the host.

        // General
        uint    samplesPerPixel = 1;            ///< Number of samples (paths) per pixel. Use compile-time constant kSamplesPerPixel in shader.
        uint    lightSamplesPerVertex = 1;      ///< Number of light samples per path vertex. Use compile-time constant kLightSamplesPerVertex in shader.
        uint    maxBounces = 3;                 ///< Max number of indirect bounces (0 = none), up to kMaxPathLength. Use compile-time constant kMaxBounces in shader.
        uint    maxNonSpecularBounces = 3;      ///< Max number of non-specular indirect bounces (0 = none), up to kMaxPathLength. Use compile-time constant kMaxNonSpecularBounces in shader.

        int     useVBuffer = 1;                 ///< Use a V-buffer as input. Use compile-time constant kUseVBuffer (or preprocessor define USE_VBUFFER) in shader.
        int     useAlphaTest = 1;               ///< Use alpha testing on non-opaque triangles. Use compile-time constant kUseAlphaTest (or preprocessor define USE_ALPHA_TEST) in shader.
        int     _removed;
        int     forceAlphaOne = true;           ///< Force the alpha channel to 1.0. Otherwise background will have alpha 0.0 and covered samples 1.0 to allow compositing. Use compile-time constant kForceAlphaOne in shader.

        int     clampSamples = false;           ///< Clamp the per-path contribution to 'clampThreshold' to reduce fireflies.
        float   clampThreshold = 10.f;
        float   specularRoughnessThreshold = 0.25f; ///< Specular reflection events are only classified as specular if the material's roughness value is equal or smaller than this threshold.
        float   _pad0;

        // Sampling
        int     useBRDFSampling = true;         ///< Use BRDF importance sampling (otherwise cosine-weighted hemisphere sampling). Use compile-time constant kUseBRDFSampling in shader.
        int     useNEE = true;                  ///< Use next-event estimation (NEE). This enables shadow ray(s) from each path vertex.
        int     useMIS = true;                  ///< Use multiple importance sampling (MIS) when NEE is enabled. This enables a scatter ray from the last path vertex. Use compile-time constant kUseMIS in shader.
        uint    misHeuristic = 1; /* (uint)MISHeuristic::PowerTwoHeuristic */   ///< MIS heuristic. Use compile-time constant kMISHeuristic in shader. TODO: Replace initializer value by enum when Slang supports it.

        float   misPowerExponent = 2.f;         ///< MIS exponent for the power heuristic. This is only used when 'PowerExpHeuristic' is chosen.
        int     useRussianRoulette = false;     ///< Use Russian roulette. Use compile-time constant kUseRussianRoulette in shader.
        float   probabilityAbsorption = 0.2f;   ///< Probability of absorption for Russian roulette.
        int     useFixedSeed = false;           ///< Use fixed random seed for the sample generator. This is useful for print() debugging.

        int     useLegacyBSDF = false;          ///< Use legacy BRDF sampling code (no support for specular transmission).
        int     useNestedDielectrics = true;    ///< Use algorithm to handle nested dielectric materials. Use compile-time constant kUseNestedDielectrics in shader.
        int     useLightsInVolumes = false;     ///< Use lights inside of volumes (transmissive materials). We typically don't want this because lights are occluded by the interface. Use compile-time constant kUseLightsInVolumes in shader.
        int     disableCaustics = false;        ///< Disable sampling of caustics. Use compile-time constant kDisableCaustics in shader.

        // Ray footprint
        float   screenSpacePixelSpreadAngle = 0.0; ///< The angle an "average" pixel spans from camera (Used by ray footprint).
        uint    rayFootprintMode = 0;           ///< Ray footprint tracking mode used for Texture LOD. See RayFootprintModes.slangh.
        uint    rayConeMode = 2;                ///< Sub-mode for the Ray Cone mode of ray footprint. 0:RayTracingGems1 (unsupported), 1:Combo, 2:Unified. See RayFootprint.slang.
        int     rayFootprintUseRoughness = 0;   ///< Integrates material roughness into the footprint calculation (only used by Ray Cone right now).

        // Runtime data
        uint2   frameDim = uint2(0, 0);         ///< Current frame dimensions in pixels.
        uint    frameCount = 0;                 ///< Frame count since scene was loaded.
        uint    prngDimension = 0;              ///< First available PRNG dimension.
    };


PathTracer.cppで設定され、StaticParams.slangの定数としても使用され（PathTracerParamsの各コメントで最後の方にUse compile-time constant k... in shader.と書いてあるやつがこれ）、  
最終的にPathTracer.cppから渡され各レイトレシェーダーで活用される変数  


### PathData.slang

### InteriorList.slang
nestedPriorityといった数値から分かるようにuseNestedDielectricsのためにある構造体で、  
レイが複数の（重なった）メッシュを通過する際に、それぞれのメッシュの内部にあるか、そしてそのマテリアルIDやどのメッシュのプライオリティが高いかを管理する構造体  
メッシュ情報はslots[INTERIOR_LIST_SLOT_COUNT]に保管され、handleIntersection()によってレイのenter（left）によるメッシュ情報のadd（remove）処理とその配列に対するプライオリティによるソートが行われる  
現状はINTERIOR_LIST_SLOT_COUNT = 2なので3つ目のメッシュが現れたら無視されてしまうことに注意  

slots[]は  

    0-26  materialID
    27    active bit
    28-31 nestedPriority
の32ビットで情報管理され、  
（ビット作成や、プライオリティの高いマテリアル取得や、スロットにメッシュ情報が入っているかなどの）必要な情報を得るための関数が用意されている  

#### InteriorListHelpers.slang
computeRelativeIoR()のみ  
ヒットしたサーフェイスとenter or leftから
InteriorListの最もプライオリティが高い媒体（ない場合は真空）とヒットしたサーフェイスとの屈折率を計算して返す関数    


### PathTracerHelpers.slang


現状PathTracer.rt.slang（MegakernelPathTracerパスプロジェクト用のシェーダー）でしか使われていない  

### LoadShadingData.slang
外部で使われている関数はloadShadingData()のみ  
CPU側で設定されたVBufferまたはGBufferと、  
pixel、frameDim、Cameraを渡して、ShadingDataを取得するための関数  

VBufferまたはGBufferはここでしか使われておらず、
この設定の違いを隠し、共通の情報であるShadingDataのみを使っていくための情報隠蔽用のヘルパーシェーダーとなっている  

VBufferはいろいろ一から必要なデータを計算や取得していくのに対し、  
GBufferは渡された値をそのままShadingDataに入れていくだけとなっているので、おそらくGBuffer

現状PathTracer.rt.slang（MegakernelPathTracerパスプロジェクト用のシェーダー）でしか使われていない  



## DXRのための低レイヤー処理関連（コマンドリストやコンパイルやハンドルやリソース周り）
DXRを使っているため、ほかの処理と違う手続きとかが必要となる  
DXRについては[NVIDIAGameWorks / DxrTutorials](https://github.com/NVIDIAGameWorks/DxrTutorials)（低レベルレイヤーから実装していくチュートリアル、三角形と影を出すくらい）とか、[NVIDIAGameWorks/GettingStartedWithRTXRayTracing](https://github.com/NVIDIAGameWorks/GettingStartedWithRTXRayTracing)（Falcorとそれを使いやすいようにしたラップクラスを用いてAOとかGIとか実装する。一方低レベルには触れない）とか、[Rey Tracing Gems : CHAPTER 3 Introduction to DirectX Raytracing](https://www.realtimerendering.com/raytracinggems/)（DXRの低レベル部分をざっくり説明）とか  

Falcorではおおよそ以下の部分の一部でDXR用実装が必要となる  
[Falcorプロジェクト内のBasePasses関連](https://github.com/tktkq9/falcor_memo/blob/main/BasePasses%E9%96%A2%E9%80%A3.md)
[ProgramVars, ParameterBlock, ProgramReflection関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVars%2C%20ParameterBlock%2C%20ProgramReflection%E9%96%A2%E9%80%A3.md)、  
[ProgramVersion, Program, Shaderファイル関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVersion%2C%20Program%2C%20Shader%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E9%96%A2%E9%80%A3.md)  
ただし、GraphicsStateといったものなどが無かったりする（代わりにGraphicsStateObjectに該当するRtStateObjectはRtProgramで管理、作成される。RenderContextでもraytrace(()でGraphicsStateの代わりにRtProgramが渡されているように、RtProgramはGraphicsStateも兼ねている）   

### Sceneでのraytrace()など
TLAS、BLASはここで作成される  
そしてここで作成されキャッシュされたTLASなどが、Sceneでのraytrace()の時にsetRaytracingShaderData()関数により設定される  
そして、RenderContextのraytrace()が呼ばれ、そこでほかのDXR用コマンドリスト処理が行われる  

このような実装から、おそらくDXR用パスを作るときはRenderContextからではなくSceneクラスからraytrace()を呼ばなければいけないと思われる  

TLAS、BLASの作成、更新はSceneのupdate()が呼ばれた時と、ここで呼ばれているsetRaytracingShaderData()が呼ばれた時のみ  

### RenderContextでのraytrace()
DXR用のコマンドリスト実行部分  
Sceneのraytrace()関数から呼ばれる  
上にも書いたが、GraphicsStateの代わりにRtProgramが渡され、ここからRtStateObjectを取得する  
そのあと、RtProgramVarsのapply()によってシェーダーテーブルに変数のハンドルが格納され、変数とシェーダーのコマンドリスト設定が行われる  
あとは[NVIDIAGameWorks / DxrTutorials](https://github.com/NVIDIAGameWorks/DxrTutorials)のonFrameRender()と同じ処理、つまりDXRで必要なテンプレディスパッチ処置をしてレイトレ実行  

### RtProgram
Programのサブクラス、DXR用Programクラス  
ラスタライズとは違うエントリーポイント（RayGen、Miss、HitGroup）を使うので、そこら辺の情報を格納するためのDescはDXR用に新しく作り直されている（ただしProgramのDescもprivateメンバ変数として保持し、使える部分は再利用している）  

Programと違いGraphicsStateの機能も兼ねていて、GraphicsStateObjectに該当するRtStateObjectはこのクラスで作成されている  
getRtsoがGraphicsStateのgetGSO()に対応する  
（DXRで必要なのはTLAS、BLAS、UAVで、ラスタライズで必要なVaoやFboなどはいらないからわざわざGraphicsStateを作る必要はなかったのかも）  

それ以外ではlocalRootSignature、DXR用エントリーポイントによるRtEntryPointGroupKernels作成とかのProgramのDXR差分の実装となっている  
（mMaxPayloadSizeとmMaxAttributesSizeは自動設定されないっぽいのでそこは事前に自分で計算して渡す必要があるようだ）  

あとsetScene()でシーンを設定する処理があるので、TLAS、BLAS用に使うのかなと思ったが、使われている形跡がないし、TLAS、BLASはSceneクラスで作成更新コマンドリスト設定が行われるのでこれは多分消し忘れ  

#### RtEntryPointGroupKernels
EntryPointGroupKernelsのサブクラス、DXR用EntryPointGroupKernels  
EntryPointGroupKernelsの他にexportName、localRootSignature、maxPayloadSize、maxAttributeSizeが格納されただけのもの  

ラスタライズの場合と同様にProgramKernelsに格納される  
RtProgramのgetRtso()で、  

    auto pProgramKernels = pProgramVersion->getKernels(pVars);
の時にRtProgramのcreateEntryPointGroupKernels()が呼ばれて作成される  

### RtStateObject
GraphicsStateObjectのDXR版  
create()でDXR用のグラフィックステートオブジェクトmApiHandleが作成される  
create()の呼び出しはRtProgramのgetRtso()で呼ばれる  

DXR用のパイプラインステートオブジェクトの生成は 
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)参照（特にcreateRtPipelineState()関数部分）  
このcreate()とそこで使われているRtStateObjectHelper（ほぼこちらで作成される）でこれに相当する処理が行われている  

#### RtStateObjectHelper
RtStateObjectのcreate()関数でのみ使われ、完了したら破棄される、RtStateObject作成ヘルパークラス  
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)の各サブオブジェクトの作成部分と、createRtPipelineState()での

    d3d_call(mpDevice->CreateStateObject(&desc, IID_PPV_ARGS(&mpPipelineState)));
    
より上の部分の処理に相当し、各サブオブジェクトに必要なデータを渡しサブオブジェクトラッパークラスRtStateSubobjectBaseを個別に作成と配列への格納、それによるD3D12_STATE_OBJECT_DESCの作成を担当する  

各々データのサブオブジェクトの作られ方は違うので、それぞれRtStateSubobjectBaseを継承した別Structを作り、そのコンストラクトでサブオブジェクトを作成  
これがadd...()の時に呼ばれて、配列に格納されていく  

変更がない場合はDescの再利用できるようにmDirty管理もされてる  

#### MAKE_SMART_COM_PTR

    MAKE_SMART_COM_PTR(ID3D12StateObjectProperties);
    
こんな表記があるが、これは3D12StateObjectPropertiesのCOMオブジェクトポインタークラスID3D12StateObjectPropertiesPtrを作るためのもの  
ここ以外でもちょいちょい使われている  

### ShaderTable
DXR特有のシェーダーテーブルクラス  
RtProgramVarsやD3D12RenderContext.cppのraytrace()で使われる  
シェーダーテーブルとは、各エントリーポイントに対しDXRシェーダー内でどのインデックスで呼び出すかを決めるためのインデックステーブル（またはエントリーポイント関数ポインター配列）みたいなもの  
必要最低限の実装をしている[DxrTutorials/Tutorials/05-ShaderTable/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/05-ShaderTable)とか、複数のエントリーポイントを考慮した[DxrTutorials / Tutorials / 13 - SecondRayType /](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/13-SecondRayType)とか参照  
そして、Falcorでのテーブルレイアウトは以下のようになっている  

       +------------+---------+---------+-----+--------+---------+--------+-----+--------+--------+-----+--------+-----+--------+--------+-----+--------+
       |            |         |         | ... |        |         |        | ... |        |        | ... |        | ... |        |        | ... |        |
       |   RayGen   |   Ray0  |   Ray1  | ... |  RayN  |   Ray0  |  Ray1  | ... |  RayN  |  Ray0  | ... |  RayN  | ... |  Ray0  |  Ray0  | ... |  RayN  |
       |   Entry    |   Miss  |   Miss  | ... |  Miss  |   Hit   |   Hit  | ... |  Hit   |  Hit   | ... |  Hit   | ... |  Hit   |  Hit   | ... |  Hit   |
       |            |         |         | ... |        |  Mesh0  |  Mesh0 | ... |  Mesh0 |  Mesh1 | ... |  Mesh1 | ... | MeshN  |  MeshN | ... |  MeshN |
       +------------+---------+---------+-----+--------+---------+--------+-----+--------+--------+-----+--------+-----+--------+--------+-----+--------+

create()では何もせず、update()でシェーダーテーブル作成を行う  
行っていることは[DxrTutorials/Tutorials/05-ShaderTable/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/05-ShaderTable)とかのcreateShaderTable()における、エントリーポイントの数と各エントリーのサイズ、オフセットの計算だけを行っている    
そこから任意のルートシグネチャーとエントリーに対し自動で作成するように実装されている  
実際にシェーダーのアイデンティファーやルートシグネチャーをバッファーに割り当てる処理（とGPUへのアップロード処理flushBuffer()の実行）はRtProgramVarsのapply()とその中で呼ばれているapplyVarsToTable()で行っている  

### RtProgramVars
DXR用ProgramVars  
ShaderTableのテーブルレイアウトに沿った実装がなされている  

create()（とその中で呼ばれているinit()）でRayGen（おそらく1個、複数作れる実装になってはいるが）、Miss（N_ray個）、HitGroupのEntryPointGroupVars（N_ray * N_mash個）のEntryPointGroupVarsを作成、保持される  

残りはapply()とそこで呼ばれている関数のみとなっている（これはRenderContext::raytrace()の時に呼ばれる）  
まずShaderTableがなければ作成し、そのアップデートが必要ならアップデートする  
そこで各SubTableType（RayGen、Miss、HitGroup）ごとにapplyVarsToTable()が呼ばれ、シェーダーテーブルバッファーの設定が行われる  
最後に[ProgramVarsのapply()](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVars%2C%20ParameterBlock%2C%20ProgramReflection%E9%96%A2%E9%80%A3.md#apply%E9%96%A2%E6%95%B0)の代わりに、グローバルルートシグネチャーに対するapplyProgramVarsCommon()を呼びだし、コマンドリストにルートシグネチャーとシェーダー変数のハンドルとそれに関する諸々を設定する（forGraphics = falseになっていることに注意）  

applyVarsToTable()の詳細は、  
SubTableTypeに対応するエントリーポイントすべてに対し、シェーダーテーブルバッファーpRecordを取得し、applyRtProgramVars()でその設定を行い、バージョン管理l用変数astObservedChangeEpochの更新を行う  

applyRtProgramVars()では、  
シェーダーテーブル設定特有の処理である、  
pRecordへのエントリーポイントのアイデンティファーの設定と、  
そのローカルルートシグネチャー変数に対応するハンドルの設定が行われる  
DXRではラスタライズと違って、シェーダー変数のハンドルはコマンドリストではなくShaderTableに設定される（つまりここでいうpRecordに設定される）  
この処理を行うにあたり、疑似コマンドリストクラスRtVarsCmdList（とそれを持つ疑似ContextクラスRtVarsContext）を使うことによって、applyProgramVarsCommon()（通常はルートシグネチャーと変数ハンドルをコマンドリストに設定する関数）でコマンドリストの代わりにpRecordにハンドルを設定するような実装となっている  

#### RtVarsContext
ローカルルートシグネチャーに対応する変数をシェーダーテーブルに設定するための疑似Cotextクラス  
ラスタライズ用の処理applyProgramVarsCommon()で無理やりシェーダーテーブルに設定できるようにするために、このような~~回りくどい~~スマートな実装となっている<font color=#FFFFFF>さすがにコードにその説明コメント書いてほしいなああああああああ</font>  
RtProgramVars以外では使われていない（ローカルルートシグネチャー関連の設定はRtProgramVarsでしか行われていないっぽいので）  

ここで行っていることはRtVarsCmdListを生成し保持することと、  
バリアー処理はこのContextではなくDeviceクラスの方のRenderContextに任せるようにすることのみ  
このコンテキストではコマンドキューを実行することはないのでこのようにバリアーは他にまかせている  

#### RtVarsCmdList
ローカルルートシグネチャーに対応する変数をシェーダーテーブルに設定するための疑似コマンドリストクラス  
行っていることはコマンドリストの設定ではなく、  
シェーダーテーブルのバッファーmpRootBaseへ変数ハンドルを設定している  
applyProgramVarsCommon()の変更なしに動くよう、通常コマンドリスト設定関数をオーバーライドし、シェーダーテーブルへの設定に差し替えている（あと、呼ばれないであろう処理はすべてshould_not_get_here()でアサートしてある）
もちろんRtVarsContextでのみ使われる  

## TALS、BLASについて
上でも書いたが、TALS、BLASはSceneクラスで作成更新設定管理されている  

TODO : SceneのTALS、BLASについて詳細  

## CPUSampleGenerator関連
CPU側で扱うサンプラー  
今のところはカメラのジッター生成にのみ使われている  

TODO : PBRTとか見て界隈ではどれがよく使われているか確認。なかったら実装も視野。確かハルトンが結構使われていた気がする  

### CPUSampleGenerator
様々なサンプルジェネレーターのインターフェースクラス  
アブストラクトクラスとなっているので使うときはこれのサブクラスを利用する  

### DxSamplePattern
CPUSampleGeneratorのサブクラス  
DirectX MSAA sample pattern generator  
nextするたびにMSAAの次のサンプル箇所に対応する値が取得できる  
8サンプル固定  

### HaltonSamplePattern
CPUSampleGeneratorのサブクラス  
Halton sample pattern generator  
ハルトンサンプラーは以下参照  
[7.4 The Halton Sampler](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler.html#)  
このPBRTv3の2Dサンプラーと同じように、(基数2サンプル, 基数3サンプル)を返す  

### StratifiedSamplePattern
CPUSampleGeneratorのサブクラス  
stratified random sample pattern generator  
Stratifiedサンプラーは以下参照  
[7.3 Stratified Sampling](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html#)  
この参照にある_Latin hypercube sampling_が実装されている（たぶんね）  

## SampleGenerator
レイトレとかGPU側で使うサンプル生成slang管理クラス  

シェーダー側のSampleGeneratorはSampleGeneratorType.slanghにある#defineでどのサンプラーを使うか決めればいいだけなので、  
このクラスではそのDefineListを管理しているだけ  

ハルトンとかは現状ない。Ray Tracing Gemsとかに実装されてるので持ってきてもいいかも  

### SampleGenerator.slang
1D、2D、3DサンプルをSampleGeneratorから作成する  
SampleGeneratorはISampleGeneratorインターフェースによってによって実装されている

ISampleGeneratorは
UniformSampleGenerator.slangとTinyUniformSampleGenerator.slangの2つであり、
SampleGeneratorType.slanghで定義されている#defineでどちらを使うが制御される  

### UniformSampleGenerator.slang
一様ランダム   
SplitMix64でpixelとsampleNumberからseedを作り、 
Xoshiroでランダム生成をしている  

### TinyUniformSampleGenerator.slang
軽い一様ランダム  
pixelとsampleNumberからseedを作り、 
LCGでランダム生成している  

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMzNzUyMTEwNywxMDU1MjY4NzU0LDY1Nj
Q1MzcxMiwxMDk4Mzc4NTg2LDQ5MDcxNjkyOCwxMTY1NjcwMCwt
MTM2OTU0NjU0MSwxODA1MTU4MTY2LC0zODU4NTUxNDgsLTExMD
I2MTMzNjgsLTM5MTY2OTg3LC0yMDcyMDExOTc5LC05NTQxMTc1
NzMsMTg0Mjc4OTAxNSwxMzU4MjA4MzQzLDE0NzgzODY3MzksOT
A4MjQ4ODg1LDE0OTcyNzcyMzYsMTI3NDc0NDU2NCwyNDkxNjE0
NjddfQ==
-->