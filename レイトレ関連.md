# レイトレ関連
Falcorプロジェクトのレイトレに関する部分のまとめ  

## FalcorプロジェクトのRtProgram関連

[Falcorプロジェクト内のBasePasses関連](https://github.com/tktkq9/falcor_memo/blob/main/BasePasses%E9%96%A2%E9%80%A3.md)
[ProgramVars, ParameterBlock, ProgramReflection関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVars%2C%20ParameterBlock%2C%20ProgramReflection%E9%96%A2%E9%80%A3.md)、  
[ProgramVersion, Program, Shaderファイル関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVersion%2C%20Program%2C%20Shader%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E9%96%A2%E9%80%A3.md)  
のうち、DXR用の処理が必要な部分の実装  
ただし、ラスタライズとは違いGraphicsStateといったものなどが無かったりする（代わりにGraphicsStateObjectに該当するRtStateObjectはRtProgramで管理、作成される。RenderContextでもraytrace(()でGraphicsStateの代わりにRtProgramが渡されているように、RtProgramはGraphicsStateも兼ねている）  



### RtProgram
Programのサブクラス、DXR用Programクラス  
ラスタライズとは違うエントリーポイント（RayGen、Miss、HitGroup）を使うので、そこら辺の情報を格納するためのDescはDXR用に新しく作り直されている（ただしProgramのDescもprivateメンバ変数として保持し、使える部分は再利用している）  

Programと違いGraphicsStateの機能も兼ねていて、GraphicsStateObjectに該当するRtStateObjectはこのクラスで作成されている  
getRtsoがGraphicsStateのgetGSO()に対応する  
（DXRで必要なのはTLAS、BLAS、UAVで、ラスタライズで必要なVaoやFboなどはいらないからわざわざGraphicsStateを作る必要はなかったのかも）  

それ以外ではlocalRootSignature、DXR用エントリーポイントによるRtEntryPointGroupKernels作成とかのProgramのDXR差分の実装となっている  
（mMaxPayloadSizeとmMaxAttributesSizeは自動設定されないっぽいのでそこは事前に自分で計算して渡す必要があるようだ）  

あとsetScene()でシーンを設定する処理があるので、TLAS、BLAS用に使うのかなと思ったが、使われている形跡がないのでこれは多分消し忘れ  

#### RtEntryPointGroupKernels
EntryPointGroupKernelsのサブクラス、DXR用EntryPointGroupKernels  
EntryPointGroupKernelsの他にexportName、localRootSignature、maxPayloadSize、maxAttributeSizeが格納されただけのもの  

ラスタライズの場合と同様にProgramKernelsに格納される  
RtProgramのgetRtso()で、  

    auto pProgramKernels = pProgramVersion->getKernels(pVars);
の時にRtProgramのcreateEntryPointGroupKernels()が呼ばれて作成される  

### RtStateObject
GraphicsStateObjectのDXR版  
create()でDXR用のグラフィックステートオブジェクトmApiHandleが作成される  
create()の呼び出しはRtProgramのgetRtso()で呼ばれる  

DXR用のパイプラインステートオブジェクトの生成は 
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)参照（特にcreateRtPipelineState()関数部分）  
このcreate()とそこで使われているRtStateObjectHelper（ほぼこちらで作成される）でこれに相当する処理が行われている  

#### RtStateObjectHelper
RtStateObjectのcreate()関数でのみ使われ、完了したら破棄される、RtStateObject作成ヘルパークラス  
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)の各サブオブジェクトの作成部分と、createRtPipelineState()での

    d3d_call(mpDevice->CreateStateObject(&desc, IID_PPV_ARGS(&mpPipelineState)));
    
より上の部分の処理に相当し、各サブオブジェクトに必要なデータを渡しサブオブジェクトラッパークラスRtStateSubobjectBaseを個別に作成と配列への格納、それによるD3D12_STATE_OBJECT_DESCの作成を担当する  

各々データのサブオブジェクトの作られ方は違うので、それぞれRtStateSubobjectBaseを継承した別Structを作り、そのコンストラクトでサブオブジェクトを作成  
これがadd...()の時に呼ばれて、配列に格納されていく  

変更がない場合はDescの再利用できるようにmDirty管理もされてる  

#### MAKE_SMART_COM_PTR

    MAKE_SMART_COM_PTR(ID3D12StateObjectProperties);
    
こんな表記があるが、これは3D12StateObjectPropertiesのCOMオブジェクトポインタークラスID3D12StateObjectPropertiesPtrを作るためのもの  
ここ以外でもちょいちょい使われている  

## CPUSampleGenerator関連
CPU側で扱うサンプラー  
今のところはカメラのジッター生成にのみ使われている  

TODO : PBRTとか見て界隈ではどれがよく使われているか確認。なかったら実装も視野。確かハルトンが結構使われていた気がする  

### CPUSampleGenerator
様々なサンプルジェネレーターのインターフェースクラス  
アブストラクトクラスとなっているので使うときはこれのサブクラスを利用する  

### DxSamplePattern
CPUSampleGeneratorのサブクラス  
DirectX MSAA sample pattern generator  
nextするたびにMSAAの次のサンプル箇所に対応する値が取得できる  
8サンプル固定  

### HaltonSamplePattern
CPUSampleGeneratorのサブクラス  
Halton sample pattern generator  
ハルトンサンプラーは以下参照  
[7.4 The Halton Sampler](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler.html#)  
このPBRTv3の2Dサンプラーと同じように、(基数2サンプル, 基数3サンプル)を返す  

### StratifiedSamplePattern
CPUSampleGeneratorのサブクラス  
stratified random sample pattern generator  
Stratifiedサンプラーは以下参照  
[7.3 Stratified Sampling](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html#)  
この参照にある_Latin hypercube sampling_が実装されている（たぶんね）  

## SampleGenerator
レイトレとかGPU側で使うサンプル生成slang管理クラス  

シェーダー側のSampleGeneratorはSampleGeneratorType.slanghにある#defineでどのサンプラーを使うか決めればいいだけなので、  
このクラスではそのDefineListを管理しているだけ  

ハルトンとかは現状ない。Ray Tracing Gemsとかに実装されてるので持ってきてもいいかも  

### SampleGenerator.slang
1D、2D、3DサンプルをSampleGeneratorから作成する  
SampleGeneratorはISampleGeneratorインターフェースによってによって実装されている

ISampleGeneratorは
UniformSampleGenerator.slangとTinyUniformSampleGenerator.slangの2つであり、
SampleGeneratorType.slanghで定義されている#defineでどちらを使うが制御される  

### UniformSampleGenerator.slang
一様ランダム   
SplitMix64でpixelとsampleNumberからseedを作り、 
Xoshiroでランダム生成をしている  

### TinyUniformSampleGenerator.slang
軽い一様ランダム  
pixelとsampleNumberからseedを作り、 
LCGでランダム生成している  

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1ODM5MjI2NjEsMTc1Mjg4Mjk1MiwtMT
UzNDAzODMyOCwxODY3Njc3NjcwLC05MzEzNjE5OCw1NjczNjI4
NDIsLTg3MjM0Njc3MywyNTQ2MDQ1NDQsLTE2MjI0Mjc4NTgsND
Q0MjI0ODgsMTQxMTE2OTY3OSwtMjUzNjI2NDE0LC01MzY4MDcy
MTIsOTE5NjY3NjM0LDMwNzkyMDIwNSwtMjA0MTQ1NDg2MSw0ND
U2MTE0NjMsNTU3NjQ0ODk1LDMzMTI3MTc5MSwtNjY2NDI2NDk1
XX0=
-->