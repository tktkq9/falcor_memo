# レイトレ関連
Falcorプロジェクトのレイトレに関する部分のまとめ  

## シェーダーのコンパイルと設定と実行関連
DXRを使っているため、ほかの処理と違う手続きとかが必要となる  
DXRについては[NVIDIAGameWorks / DxrTutorials](https://github.com/NVIDIAGameWorks/DxrTutorials)（低レベルレイヤーから実装していくチュートリアル、三角形と影を出すくらい）とか、[NVIDIAGameWorks/GettingStartedWithRTXRayTracing](https://github.com/NVIDIAGameWorks/GettingStartedWithRTXRayTracing)（Falcorとそれを使いやすいようにしたラップクラスを用いてAOとかGIとか実装する。一方低レベルには触れない）とか、[Rey Tracing Gems : CHAPTER 3 Introduction to DirectX Raytracing](https://www.realtimerendering.com/raytracinggems/)（DXRの低レベル部分をざっくり説明）とか  

Falcorではおおよそ以下の部分の一部でDXR用実装が必要となる  
[Falcorプロジェクト内のBasePasses関連](https://github.com/tktkq9/falcor_memo/blob/main/BasePasses%E9%96%A2%E9%80%A3.md)
[ProgramVars, ParameterBlock, ProgramReflection関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVars%2C%20ParameterBlock%2C%20ProgramReflection%E9%96%A2%E9%80%A3.md)、  
[ProgramVersion, Program, Shaderファイル関連](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVersion%2C%20Program%2C%20Shader%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E9%96%A2%E9%80%A3.md)  
ただし、ラスタライズとは違いGraphicsStateといったものなどが無かったりもする（代わりにGraphicsStateObjectに該当するRtStateObjectはRtProgramで管理、作成される。RenderContextでもraytrace(()でGraphicsStateの代わりにRtProgramが渡されているように、RtProgramはGraphicsStateも兼ねている）  

### RtProgram
Programのサブクラス、DXR用Programクラス  
ラスタライズとは違うエントリーポイント（RayGen、Miss、HitGroup）を使うので、そこら辺の情報を格納するためのDescはDXR用に新しく作り直されている（ただしProgramのDescもprivateメンバ変数として保持し、使える部分は再利用している）  

Programと違いGraphicsStateの機能も兼ねていて、GraphicsStateObjectに該当するRtStateObjectはこのクラスで作成されている  
getRtsoがGraphicsStateのgetGSO()に対応する  
（DXRで必要なのはTLAS、BLAS、UAVで、ラスタライズで必要なVaoやFboなどはいらないからわざわざGraphicsStateを作る必要はなかったのかも）  

それ以外ではlocalRootSignature、DXR用エントリーポイントによるRtEntryPointGroupKernels作成とかのProgramのDXR差分の実装となっている  
（mMaxPayloadSizeとmMaxAttributesSizeは自動設定されないっぽいのでそこは事前に自分で計算して渡す必要があるようだ）  

あとsetScene()でシーンを設定する処理があるので、TLAS、BLAS用に使うのかなと思ったが、使われている形跡がないのでこれは多分消し忘れ  

#### RtEntryPointGroupKernels
EntryPointGroupKernelsのサブクラス、DXR用EntryPointGroupKernels  
EntryPointGroupKernelsの他にexportName、localRootSignature、maxPayloadSize、maxAttributeSizeが格納されただけのもの  

ラスタライズの場合と同様にProgramKernelsに格納される  
RtProgramのgetRtso()で、  

    auto pProgramKernels = pProgramVersion->getKernels(pVars);
の時にRtProgramのcreateEntryPointGroupKernels()が呼ばれて作成される  

### RtStateObject
GraphicsStateObjectのDXR版  
create()でDXR用のグラフィックステートオブジェクトmApiHandleが作成される  
create()の呼び出しはRtProgramのgetRtso()で呼ばれる  

DXR用のパイプラインステートオブジェクトの生成は 
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)参照（特にcreateRtPipelineState()関数部分）  
このcreate()とそこで使われているRtStateObjectHelper（ほぼこちらで作成される）でこれに相当する処理が行われている  

#### RtStateObjectHelper
RtStateObjectのcreate()関数でのみ使われ、完了したら破棄される、RtStateObject作成ヘルパークラス  
[dxrtutorials/Tutorials/04-RtPipelineState/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/04-RtPipelineState)の各サブオブジェクトの作成部分と、createRtPipelineState()での

    d3d_call(mpDevice->CreateStateObject(&desc, IID_PPV_ARGS(&mpPipelineState)));
    
より上の部分の処理に相当し、各サブオブジェクトに必要なデータを渡しサブオブジェクトラッパークラスRtStateSubobjectBaseを個別に作成と配列への格納、それによるD3D12_STATE_OBJECT_DESCの作成を担当する  

各々データのサブオブジェクトの作られ方は違うので、それぞれRtStateSubobjectBaseを継承した別Structを作り、そのコンストラクトでサブオブジェクトを作成  
これがadd...()の時に呼ばれて、配列に格納されていく  

変更がない場合はDescの再利用できるようにmDirty管理もされてる  

#### MAKE_SMART_COM_PTR

    MAKE_SMART_COM_PTR(ID3D12StateObjectProperties);
    
こんな表記があるが、これは3D12StateObjectPropertiesのCOMオブジェクトポインタークラスID3D12StateObjectPropertiesPtrを作るためのもの  
ここ以外でもちょいちょい使われている  

### ShaderTable
DXR特有のシェーダーテーブルクラス  
RtProgramVarsやD3D12RenderContext.cppのraytrace()で使われる  
シェーダーテーブルとは、各エントリーポイントに対しDXRシェーダー内でどのインデックスで呼び出すかを決めるためのインデックステーブル（またはエントリーポイント関数ポインター配列）みたいなもの  
必要最低限の実装をしている[DxrTutorials/Tutorials/05-ShaderTable/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/05-ShaderTable)とか、複数のエントリーポイントを考慮した[DxrTutorials / Tutorials / 13 - SecondRayType /](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/13-SecondRayType)とか参照  
そして、Falcorでのテーブルレイアウトは以下のようになっている  

       +------------+---------+---------+-----+--------+---------+--------+-----+--------+--------+-----+--------+-----+--------+--------+-----+--------+
       |            |         |         | ... |        |         |        | ... |        |        | ... |        | ... |        |        | ... |        |
       |   RayGen   |   Ray0  |   Ray1  | ... |  RayN  |   Ray0  |  Ray1  | ... |  RayN  |  Ray0  | ... |  RayN  | ... |  Ray0  |  Ray0  | ... |  RayN  |
       |   Entry    |   Miss  |   Miss  | ... |  Miss  |   Hit   |   Hit  | ... |  Hit   |  Hit   | ... |  Hit   | ... |  Hit   |  Hit   | ... |  Hit   |
       |            |         |         | ... |        |  Mesh0  |  Mesh0 | ... |  Mesh0 |  Mesh1 | ... |  Mesh1 | ... | MeshN  |  MeshN | ... |  MeshN |
       +------------+---------+---------+-----+--------+---------+--------+-----+--------+--------+-----+--------+-----+--------+--------+-----+--------+

create()では何もせず、update()でシェーダーテーブル作成を行う  
行っていることは[DxrTutorials/Tutorials/05-ShaderTable/](https://github.com/NVIDIAGameWorks/DxrTutorials/tree/master/Tutorials/05-ShaderTable)とかのcreateShaderTable()における、エントリーポイントの数と各エントリーのサイズ、オフセットの計算だけを行っている    
そこから任意のルートシグネチャーとエントリーに対し自動で作成するように実装されている  
実際にシェーダーのアイデンティファーやルートシグネチャーをバッファーに割り当てる処理（とGPUへのアップロード処理flushBuffer()の実行）はRtProgramVarsのapply()とその中で呼ばれているapplyVarsToTable()で行っている  

### RtProgramVars
DXR用ProgramVars  
ShaderTableのテーブルレイアウトに沿った実装がなされている  

create()（とその中で呼ばれているinit()）でRayGen（おそらく1個、複数作れる実装になってはいるが）、Miss（N_ray個）、HitGroupのEntryPointGroupVars（N_ray * N_mash個）のEntryPointGroupVarsを作成、保持される  

残りはapply()とそこで呼ばれている関数のみとなっている（これはRenderContext::raytrace()の時に呼ばれる）  
まずShaderTableがなければ作成し、そのアップデートが必要ならアップデートする  
そこで各SubTableType（RayGen、Miss、HitGroup）ごとにapplyVarsToTable()が呼ばれ、シェーダーテーブルバッファーの設定とローカルルートシグネチャーとその変数関連のコマンドリスト設定が行われる  
最後に[ProgramVarsのapply()](https://github.com/tktkq9/falcor_memo/blob/main/ProgramVars%2C%20ParameterBlock%2C%20ProgramReflection%E9%96%A2%E9%80%A3.md#apply%E9%96%A2%E6%95%B0)の代わりに、グローバルルートシグネチャーに対するapplyProgramVarsCommon()を呼びだし、コマンドリストにルートシグネチャーとシェーダー変数のハンドルとそれに関する諸々を設定する（forGraphics = falseになっていることに注意）  

applyVarsToTable()の詳細は、  
SubTableTypeに対応するエントリーポイントすべてに対し、シェーダーテーブルバッファーpRecordを取得し、applyRtProgramVars()でその設定を行い、バージョン管理l用変数astObservedChangeEpochの更新を行う  

applyRtProgramVars()では、  
シェーダーテーブル設定特有の処理である、  
pRecordへのエントリーポイントのアイデンティファーの設定と、  
エントリーポイントに対応するローカルルートシグネチャーの設定が行われる  
また、ここでローカルルートシグネチャーとその変数ハンドルのコマンドリスト設定がapplyProgramVarsCommon()によって行われる（グローバルルートシグネチャーと違いこちらではforGraphics = trueになっていることに注意）  

#### RtVarsCmdList

#### RtVarsContext


## CPUSampleGenerator関連
CPU側で扱うサンプラー  
今のところはカメラのジッター生成にのみ使われている  

TODO : PBRTとか見て界隈ではどれがよく使われているか確認。なかったら実装も視野。確かハルトンが結構使われていた気がする  

### CPUSampleGenerator
様々なサンプルジェネレーターのインターフェースクラス  
アブストラクトクラスとなっているので使うときはこれのサブクラスを利用する  

### DxSamplePattern
CPUSampleGeneratorのサブクラス  
DirectX MSAA sample pattern generator  
nextするたびにMSAAの次のサンプル箇所に対応する値が取得できる  
8サンプル固定  

### HaltonSamplePattern
CPUSampleGeneratorのサブクラス  
Halton sample pattern generator  
ハルトンサンプラーは以下参照  
[7.4 The Halton Sampler](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler.html#)  
このPBRTv3の2Dサンプラーと同じように、(基数2サンプル, 基数3サンプル)を返す  

### StratifiedSamplePattern
CPUSampleGeneratorのサブクラス  
stratified random sample pattern generator  
Stratifiedサンプラーは以下参照  
[7.3 Stratified Sampling](http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html#)  
この参照にある_Latin hypercube sampling_が実装されている（たぶんね）  

## SampleGenerator
レイトレとかGPU側で使うサンプル生成slang管理クラス  

シェーダー側のSampleGeneratorはSampleGeneratorType.slanghにある#defineでどのサンプラーを使うか決めればいいだけなので、  
このクラスではそのDefineListを管理しているだけ  

ハルトンとかは現状ない。Ray Tracing Gemsとかに実装されてるので持ってきてもいいかも  

### SampleGenerator.slang
1D、2D、3DサンプルをSampleGeneratorから作成する  
SampleGeneratorはISampleGeneratorインターフェースによってによって実装されている

ISampleGeneratorは
UniformSampleGenerator.slangとTinyUniformSampleGenerator.slangの2つであり、
SampleGeneratorType.slanghで定義されている#defineでどちらを使うが制御される  

### UniformSampleGenerator.slang
一様ランダム   
SplitMix64でpixelとsampleNumberからseedを作り、 
Xoshiroでランダム生成をしている  

### TinyUniformSampleGenerator.slang
軽い一様ランダム  
pixelとsampleNumberからseedを作り、 
LCGでランダム生成している  

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM4Mjc3ODMzNiwxNTUwMzMwODM2LDE2Mz
Q0MDU3NDcsNzI1Mjk2NDMxLC0xNzY3MTQ5MzYwLC0xNzY3MTQ5
MzYwLDEzMTYxOTI3NjAsLTIyMDY1NjYzMywtMTc2NDI1NjIzNC
wxMjcxMzA2NjQ3LC04MzA2MjM1ODYsMTA4NTIxOTI4NiwtMTU0
NDAyOTYxNiwtMTQ1MjA0MDQxOCwxNjA2ODcwMDY4LC0yMDI3Mz
UxMTcyLDMzODU4MDkxMSwtMzc5ODQzODcxLDM2MDQ5MDIxLC0x
NTY0NzI5MzM5XX0=
-->